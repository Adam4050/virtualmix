import React, { useState, useEffect, useRef, useCallback } from 'react';
import { Play, Pause, SkipBack, Upload, Power, Disc, Volume2, Settings2, Music } from 'lucide-react';

// --- POMOCNÉ KOMPONENTY PRO HARDWARE VZHLED S DOTYKOVOU PODPOROU ---

// Otočný knob (potenciometr)
const Knob = ({ value, min, max, onChange, label, size = 48, color = 'bg-stone-800', indicatorColor = 'bg-white' }) => {
  const [isDragging, setIsDragging] = useState(false);
  const startY = useRef(0);
  const startVal = useRef(0);

  const calculateRotation = () => {
    const percentage = (value - min) / (max - min);
    return -135 + (percentage * 270); // Od -135 do +135 stupňů
  };

  const handleInteractionStart = (y, currentVal) => {
    setIsDragging(true);
    startY.current = y;
    startVal.current = currentVal;
  };

  const handleMouseDown = (e) => handleInteractionStart(e.clientY, value);
  const handleTouchStart = (e) => handleInteractionStart(e.touches[0].clientY, value);

  useEffect(() => {
    const handleMove = (y) => {
      if (!isDragging) return;
      const deltaY = startY.current - y;
      const range = max - min;
      // Citlivost: 100px posun myši/prstu = celá škála
      let newVal = startVal.current + (deltaY / 100) * range; 
      newVal = Math.max(min, Math.min(max, newVal));
      onChange(newVal);
    };

    const handleMouseMove = (e) => handleMove(e.clientY);
    const handleTouchMove = (e) => handleMove(e.touches[0].clientY);
    const handleEnd = () => setIsDragging(false);

    if (isDragging) {
      window.addEventListener('mousemove', handleMouseMove);
      window.addEventListener('mouseup', handleEnd);
      window.addEventListener('touchmove', handleTouchMove, { passive: false });
      window.addEventListener('touchend', handleEnd);
    }
    return () => {
      window.removeEventListener('mousemove', handleMouseMove);
      window.removeEventListener('mouseup', handleEnd);
      window.removeEventListener('touchmove', handleTouchMove);
      window.removeEventListener('touchend', handleEnd);
    };
  }, [isDragging, max, min, onChange]);

  return (
    <div className="flex flex-col items-center gap-1 select-none">
      <div 
        className={`relative rounded-full shadow-[0_5px_10px_rgba(0,0,0,0.5),inset_0_2px_2px_rgba(255,255,255,0.1)] border border-black/50 flex items-center justify-center cursor-ns-resize touch-none ${color}`}
        style={{ width: size, height: size, transform: `rotate(${calculateRotation()}deg)` }}
        onMouseDown={handleMouseDown}
        onTouchStart={handleTouchStart}
      >
        <div className="absolute top-0 w-1 h-3/5 rounded-full pointer-events-none" style={{ transformOrigin: 'bottom center', transform: 'translateY(-2px)' }}>
           <div className={`w-full h-1/2 ${indicatorColor} rounded-full`}></div>
        </div>
        {/* Jemná textura knobu */}
        <div className="w-[80%] h-[80%] rounded-full bg-gradient-to-br from-white/5 to-black/20 shadow-[inset_0_0_5px_rgba(0,0,0,0.5)] pointer-events-none"></div>
      </div>
      {label && <span className="text-[10px] font-bold text-stone-400 tracking-wider uppercase">{label}</span>}
    </div>
  );
};

// Vertikální tahový fader
const VLevelFader = ({ value, min, max, onChange, label }) => {
  return (
    <div className="flex flex-col items-center gap-2 select-none h-48 touch-none">
       <div className="relative flex-1 w-8 bg-black rounded shadow-[inset_0_0_10px_rgba(0,0,0,0.8)] border border-stone-800 flex justify-center py-2">
         {/* Dráha */}
         <div className="w-1 h-full bg-stone-900 rounded-full shadow-[inset_0_0_2px_black]"></div>
         {/* Samotný slider */}
         <input 
            type="range" 
            min={min} max={max} step="0.01" 
            value={value} 
            onChange={(e) => onChange(parseFloat(e.target.value))}
            className="absolute top-0 left-0 w-full h-full opacity-0 cursor-ns-resize appearance-none [writing-mode:bt-lr] touch-none z-10"
            style={{ WebkitAppearance: 'slider-vertical' }}
          />
          {/* Vizuální klobouček faderu */}
          <div 
            className="absolute w-6 h-8 bg-stone-700 rounded shadow-[0_5px_10px_rgba(0,0,0,0.5),inset_0_1px_1px_rgba(255,255,255,0.2)] border border-stone-900 pointer-events-none flex flex-col justify-center items-center gap-[2px]"
            style={{ bottom: `${((value - min) / (max - min)) * 100}%`, transform: 'translateY(50%)' }}
          >
             <div className="w-4 h-[2px] bg-white/50"></div>
             <div className="w-4 h-[2px] bg-white/50"></div>
          </div>
       </div>
       {label && <span className="text-[10px] font-bold text-stone-400 tracking-wider uppercase mt-2">{label}</span>}
    </div>
  );
}

// Horizontální Crossfader
const Crossfader = ({ value, onChange }) => {
  return (
     <div className="w-full h-12 bg-black rounded shadow-[inset_0_0_10px_rgba(0,0,0,0.8)] border border-stone-800 relative flex items-center px-4 touch-none">
        <div className="w-full h-1 bg-stone-900 rounded-full shadow-[inset_0_0_2px_black]"></div>
        <input 
            type="range" 
            min="-1" max="1" step="0.01" 
            value={value} 
            onChange={(e) => onChange(parseFloat(e.target.value))}
            className="absolute left-0 top-0 w-full h-full opacity-0 cursor-ew-resize z-10 touch-none"
        />
        <div 
            className="absolute w-10 h-10 bg-stone-800 rounded shadow-[0_5px_10px_rgba(0,0,0,0.5),inset_0_1px_1px_rgba(255,255,255,0.2)] border border-stone-900 pointer-events-none flex justify-center items-center gap-[2px]"
            style={{ left: `calc(${((value + 1) / 2) * 100}% - 20px)` }}
          >
             <div className="h-6 w-[2px] bg-white/50"></div>
             <div className="h-6 w-[2px] bg-white/50"></div>
        </div>
     </div>
  )
}

// Interaktivní Jog Wheel s dotykovou podporou
const JogWheel = ({ isPlaying, onScrub, progress }) => {
  const [rotation, setRotation] = useState(0);
  const [isDragging, setIsDragging] = useState(false);
  const startX = useRef(0);
  const animationRef = useRef(null);

  // Animace točení při přehrávání
  useEffect(() => {
    if (isPlaying && !isDragging) {
      let lastTime = performance.now();
      const animate = (time) => {
        const delta = time - lastTime;
        setRotation(prev => (prev + delta * 0.1) % 360);
        lastTime = time;
        animationRef.current = requestAnimationFrame(animate);
      };
      animationRef.current = requestAnimationFrame(animate);
    } else {
      cancelAnimationFrame(animationRef.current);
    }
    return () => cancelAnimationFrame(animationRef.current);
  }, [isPlaying, isDragging]);

  const handleInteractionStart = (x) => {
    setIsDragging(true);
    startX.current = x;
  };

  const handleMouseDown = (e) => handleInteractionStart(e.clientX);
  const handleTouchStart = (e) => handleInteractionStart(e.touches[0].clientX);

  useEffect(() => {
    const handleMove = (x) => {
      if (!isDragging) return;
      const deltaX = x - startX.current;
      startX.current = x;
      
      // Vizuální točení
      setRotation(prev => prev + deltaX);
      
      // Posun zvuku (scrubbing)
      if (onScrub) {
         onScrub(deltaX * 0.05);
      }
    };

    const handleMouseMove = (e) => handleMove(e.clientX);
    const handleTouchMove = (e) => handleMove(e.touches[0].clientX);
    const handleEnd = () => setIsDragging(false);

    if (isDragging) {
      window.addEventListener('mousemove', handleMouseMove);
      window.addEventListener('mouseup', handleEnd);
      window.addEventListener('touchmove', handleTouchMove, { passive: false });
      window.addEventListener('touchend', handleEnd);
    }
    return () => {
      window.removeEventListener('mousemove', handleMouseMove);
      window.removeEventListener('mouseup', handleEnd);
      window.removeEventListener('touchmove', handleTouchMove);
      window.removeEventListener('touchend', handleEnd);
    };
  }, [isDragging, onScrub]);

  return (
    <div className="relative w-64 h-64 md:w-72 md:h-72 bg-black rounded-full shadow-[0_10px_30px_rgba(0,0,0,0.8),inset_0_2px_5px_rgba(255,255,255,0.2)] border-4 border-stone-800 flex items-center justify-center touch-none">
      {/* Vnější kroužek (pro drag/touch) */}
      <div 
        className="absolute inset-2 rounded-full border-[12px] border-stone-900 shadow-[inset_0_0_15px_rgba(0,0,0,1)] cursor-grab active:cursor-grabbing z-20 touch-none"
        onMouseDown={handleMouseDown}
        onTouchStart={handleTouchStart}
      >
        {/* Značka pro vizualizaci rotace */}
        <div 
          className="w-full h-full rounded-full relative pointer-events-none transition-none"
          style={{ transform: `rotate(${rotation}deg)` }}
        >
           <div className="absolute top-0 left-1/2 -translate-x-1/2 w-2 h-6 bg-red-500 rounded-sm shadow-[0_0_10px_red]"></div>
           {/* Drážky vinylu */}
           <div className="absolute inset-4 rounded-full border border-white/5"></div>
           <div className="absolute inset-8 rounded-full border border-white/5"></div>
           <div className="absolute inset-12 rounded-full border border-white/5"></div>
        </div>
      </div>
      
      {/* Středový displej (neprotáčí se celý, ukazuje info) */}
      <div className="w-24 h-24 bg-stone-950 rounded-full shadow-[inset_0_0_20px_black] border-2 border-stone-800 z-10 flex flex-col items-center justify-center relative overflow-hidden pointer-events-none">
         {/* Kruhový progress bar */}
         <svg className="absolute inset-0 w-full h-full" viewBox="0 0 100 100">
            <circle cx="50" cy="50" r="46" fill="transparent" stroke="#333" strokeWidth="4" />
            <circle cx="50" cy="50" r="46" fill="transparent" stroke={isPlaying ? "#3b82f6" : "#666"} strokeWidth="4" 
                    strokeDasharray="289" strokeDashoffset={289 - (progress / 100) * 289} 
                    strokeLinecap="round" className="transition-all duration-100 ease-linear"
                    transform="rotate(-90 50 50)" />
         </svg>
         <Disc size={24} className={isPlaying ? "text-blue-500" : "text-stone-600"} />
         <span className="text-[10px] text-stone-400 mt-1 font-mono font-bold">JOG</span>
      </div>
    </div>
  );
};

// Generátor Reverb impulzu pro efekt
const createReverbBuffer = (ctx) => {
  const length = ctx.sampleRate * 2.5; // 2.5 sec decay
  const buffer = ctx.createBuffer(2, length, ctx.sampleRate);
  for (let c = 0; c < 2; c++) {
    const channelData = buffer.getChannelData(c);
    for (let i = 0; i < length; i++) {
      channelData[i] = (Math.random() * 2 - 1) * Math.pow(1 - i / length, 3);
    }
  }
  return buffer;
};


// --- HLAVNÍ APLIKACE ---

export default function App() {
  const [isPowered, setIsPowered] = useState(false);
  
  // Audio Context & Master
  const audioCtxRef = useRef(null);
  const [masterVol, setMasterVol] = useState(1);
  const [crossfader, setCrossfader] = useState(0);

  // Struktura stavu pro Deck
  const createDeckState = () => ({
    src: null,
    fileName: "Žádný track",
    isPlaying: false,
    duration: 0,
    currentTime: 0,
    pitch: 1,
    vol: 0.8,
    eqHigh: 0,
    eqMid: 0,
    eqLow: 0,
    filter: 0,
    fxType: 'echo',
    fxAmount: 0,
    hotCues: [null, null, null],
    loopIn: null,     // LOOP Start
    loopOut: null,    // LOOP End
    loopActive: false // LOOP Zapnuto/Vypnuto
  });

  const [deckA, setDeckA] = useState(createDeckState());
  const [deckB, setDeckB] = useState(createDeckState());

  // Zvukové uzly
  const nodesA = useRef({});
  const nodesB = useRef({});
  const audioRefA = useRef(null);
  const audioRefB = useRef(null);
  const loopFrameRef = useRef(null);

  // Beatmaker State
  const [isBeatmakerPlaying, setIsBeatmakerPlaying] = useState(false);
  const [bpm, setBpm] = useState(128);
  const [currentStep, setCurrentStep] = useState(0);
  const [grid, setGrid] = useState([
    [true, false, false, false, true, false, false, false, true, false, false, false, true, false, false, false],
    [false, false, false, false, true, false, false, false, false, false, false, false, true, false, false, false],
    [true, true, false, true, true, true, false, true, true, true, false, true, true, true, false, true],
    [false, false, true, false, false, false, true, false, false, false, true, false, false, false, true, false]
  ]);

  // Inicializace systému
  const powerOn = () => {
    if (!audioCtxRef.current) {
      audioCtxRef.current = new (window.AudioContext || window.webkitAudioContext)();
    }
    if (audioCtxRef.current.state === 'suspended') {
      audioCtxRef.current.resume();
    }
    setIsPowered(true);
  };

  // Vytvoření Web Audio grafu
  const initDeckAudio = (deckId, audioElement) => {
    if (!audioCtxRef.current) return;
    const ctx = audioCtxRef.current;
    const nodes = deckId === 'A' ? nodesA.current : nodesB.current;

    if (nodes.source) return; 

    try {
      const source = ctx.createMediaElementSource(audioElement);
      
      const low = ctx.createBiquadFilter(); low.type = 'lowshelf'; low.frequency.value = 250;
      const mid = ctx.createBiquadFilter(); mid.type = 'peaking'; mid.frequency.value = 1000; mid.Q.value = 1;
      const high = ctx.createBiquadFilter(); high.type = 'highshelf'; high.frequency.value = 4000;
      const filter = ctx.createBiquadFilter(); filter.type = 'allpass';
      
      const gain = ctx.createGain(); 
      const crossGain = ctx.createGain();
      const masterGain = ctx.createGain();

      const delay = ctx.createDelay(2.0); delay.delayTime.value = 0.375;
      const feedback = ctx.createGain(); feedback.gain.value = 0.5;
      delay.connect(feedback); feedback.connect(delay);
      const delayWet = ctx.createGain(); delayWet.gain.value = 0;

      const reverb = ctx.createConvolver();
      reverb.buffer = createReverbBuffer(ctx);
      const reverbWet = ctx.createGain(); reverbWet.gain.value = 0;

      source.connect(low); low.connect(mid); mid.connect(high); high.connect(filter);
      filter.connect(gain);
      
      gain.connect(delay); delay.connect(delayWet);
      gain.connect(reverb); reverb.connect(reverbWet);

      gain.connect(crossGain);
      delayWet.connect(crossGain);
      reverbWet.connect(crossGain);

      crossGain.connect(masterGain);
      masterGain.connect(ctx.destination);

      if(deckId === 'A') {
        nodesA.current = { source, low, mid, high, filter, gain, crossGain, masterGain, delayWet, reverbWet };
      } else {
        nodesB.current = { source, low, mid, high, filter, gain, crossGain, masterGain, delayWet, reverbWet };
      }
    } catch (e) {
      console.warn("Audio node creation failed. Might be already created.", e);
    }
  };

  // Aplikace parametrů mixáku
  const applyMixerParams = (deckId, state) => {
    const nodes = deckId === 'A' ? nodesA.current : nodesB.current;
    if (!nodes.gain) return;

    nodes.low.gain.value = state.eqLow;
    nodes.mid.gain.value = state.eqMid;
    nodes.high.gain.value = state.eqHigh;

    if (state.filter === 0) {
      nodes.filter.type = 'allpass';
    } else if (state.filter < 0) {
      nodes.filter.type = 'lowpass';
      nodes.filter.frequency.value = Math.max(50, 20000 * (1 + state.filter)); 
      nodes.filter.Q.value = 2;
    } else {
      nodes.filter.type = 'highpass';
      nodes.filter.frequency.value = 20 + (10000 * state.filter);
      nodes.filter.Q.value = 2;
    }

    if (nodes.delayWet && nodes.reverbWet) {
      nodes.delayWet.gain.value = state.fxType === 'echo' ? state.fxAmount : 0;
      nodes.reverbWet.gain.value = state.fxType === 'reverb' ? state.fxAmount * 1.5 : 0; 
    }

    nodes.gain.gain.value = state.vol;

    let cGain = 1;
    if (deckId === 'A') {
       cGain = crossfader > 0 ? 1 - crossfader : 1;
    } else {
       cGain = crossfader < 0 ? 1 + crossfader : 1;
    }
    nodes.crossGain.gain.value = cGain;
    nodes.masterGain.gain.value = masterVol;
  };

  useEffect(() => { applyMixerParams('A', deckA); }, [deckA, crossfader, masterVol]);
  useEffect(() => { applyMixerParams('B', deckB); }, [deckB, crossfader, masterVol]);

  useEffect(() => { if (audioRefA.current) audioRefA.current.playbackRate = deckA.pitch; }, [deckA.pitch]);
  useEffect(() => { if (audioRefB.current) audioRefB.current.playbackRate = deckB.pitch; }, [deckB.pitch]);

  // --- LOOP SYSTÉM (Vysokofrekvenční hlídač) ---
  useEffect(() => {
    const checkLoops = () => {
      // Hlídání Decku A
      if (deckA.loopActive && deckA.loopIn !== null && deckA.loopOut !== null && audioRefA.current) {
         if (audioRefA.current.currentTime >= deckA.loopOut - 0.02) {
           audioRefA.current.currentTime = deckA.loopIn;
         }
      }
      // Hlídání Decku B
      if (deckB.loopActive && deckB.loopIn !== null && deckB.loopOut !== null && audioRefB.current) {
         if (audioRefB.current.currentTime >= deckB.loopOut - 0.02) {
           audioRefB.current.currentTime = deckB.loopIn;
         }
      }
      loopFrameRef.current = requestAnimationFrame(checkLoops);
    }
    loopFrameRef.current = requestAnimationFrame(checkLoops);
    return () => cancelAnimationFrame(loopFrameRef.current);
  }, [deckA.loopActive, deckA.loopIn, deckA.loopOut, deckB.loopActive, deckB.loopIn, deckB.loopOut]);


  // --- OBSLUHA DECKŮ A TLAČÍTEK ---
  const handleFileUpload = (deckId, e) => {
    const file = e.target.files[0];
    if (file) {
      const url = URL.createObjectURL(file);
      const updateDeck = deckId === 'A' ? setDeckA : setDeckB;
      
      updateDeck(prev => ({ 
        ...prev, 
        src: url, 
        fileName: file.name, 
        isPlaying: false, 
        currentTime: 0,
        loopIn: null, // Reset loops při nahrání nové skladby
        loopOut: null,
        loopActive: false
      }));
      
      setTimeout(() => {
         const ref = deckId === 'A' ? audioRefA.current : audioRefB.current;
         if (ref) {
            initDeckAudio(deckId, ref);
            ref.load();
         }
      }, 100);
    }
  };

  const togglePlay = (deckId) => {
    if (!isPowered) return;
    const ref = deckId === 'A' ? audioRefA.current : audioRefB.current;
    const state = deckId === 'A' ? deckA : deckB;
    const setState = deckId === 'A' ? setDeckA : setDeckB;

    if (!ref || !state.src) return;

    if (state.isPlaying) {
      ref.pause();
      setState(p => ({ ...p, isPlaying: false }));
    } else {
      if(audioCtxRef.current && audioCtxRef.current.state === 'suspended') audioCtxRef.current.resume();
      ref.play();
      setState(p => ({ ...p, isPlaying: true }));
    }
  };

  const handleTimeUpdate = (deckId) => {
    const ref = deckId === 'A' ? audioRefA.current : audioRefB.current;
    const setState = deckId === 'A' ? setDeckA : setDeckB;
    if (ref) {
      setState(p => ({ ...p, currentTime: ref.currentTime, duration: ref.duration || 0 }));
    }
  };

  const handleCue = (deckId) => {
    const ref = deckId === 'A' ? audioRefA.current : audioRefB.current;
    const setState = deckId === 'A' ? setDeckA : setDeckB;
    if (ref) {
      ref.currentTime = 0;
      ref.pause();
      setState(p => ({ ...p, isPlaying: false, currentTime: 0 }));
    }
  };

  const handleHotCue = (deckId, index) => {
    const ref = deckId === 'A' ? audioRefA.current : audioRefB.current;
    const state = deckId === 'A' ? deckA : deckB;
    const setState = deckId === 'A' ? setDeckA : setDeckB;
    
    if (!ref || !state.src) return;

    if (state.hotCues[index] === null) {
      const newCues = [...state.hotCues];
      newCues[index] = ref.currentTime;
      setState(p => ({ ...p, hotCues: newCues }));
    } else {
      ref.currentTime = state.hotCues[index];
      if (!state.isPlaying) {
         if(audioCtxRef.current && audioCtxRef.current.state === 'suspended') audioCtxRef.current.resume();
         ref.play();
         setState(p => ({ ...p, isPlaying: true }));
      }
    }
  };

  // --- LOOPS HANDLERY ---
  const handleLoopIn = (deckId) => {
    const ref = deckId === 'A' ? audioRefA.current : audioRefB.current;
    const setState = deckId === 'A' ? setDeckA : setDeckB;
    if (!ref) return;
    setState(p => ({ ...p, loopIn: ref.currentTime }));
  };

  const handleLoopOut = (deckId) => {
    const ref = deckId === 'A' ? audioRefA.current : audioRefB.current;
    const state = deckId === 'A' ? deckA : deckB;
    const setState = deckId === 'A' ? setDeckA : setDeckB;
    if (!ref) return;

    const outTime = ref.currentTime;
    const inTime = state.loopIn !== null ? state.loopIn : 0;

    if (outTime > inTime) {
       setState(p => ({ ...p, loopIn: inTime, loopOut: outTime, loopActive: true }));
    }
  };

  const toggleLoop = (deckId) => {
    const ref = deckId === 'A' ? audioRefA.current : audioRefB.current;
    const state = deckId === 'A' ? deckA : deckB;
    const setState = deckId === 'A' ? setDeckA : setDeckB;
    if (!ref || state.loopIn === null || state.loopOut === null) return;

    if (!state.loopActive) {
       // Reloop (skoč na In a hraj ve smyčce)
       ref.currentTime = state.loopIn;
       setState(p => ({ ...p, loopActive: true }));
       if (!state.isPlaying) {
         if(audioCtxRef.current && audioCtxRef.current.state === 'suspended') audioCtxRef.current.resume();
         ref.play();
         setState(p => ({ ...p, isPlaying: true }));
       }
    } else {
       // Exit (jen vypni smyčku a pokračuj ve hraní)
       setState(p => ({ ...p, loopActive: false }));
    }
  };

  const handleScrub = (deckId, delta) => {
    const ref = deckId === 'A' ? audioRefA.current : audioRefB.current;
    if (ref && ref.duration) {
      let newTime = ref.currentTime + delta;
      newTime = Math.max(0, Math.min(ref.duration, newTime));
      ref.currentTime = newTime;
    }
  };

  // --- BEATMAKER ---
  const timerIDRef = useRef(null);
  const nextNoteTimeRef = useRef(0);
  const currentStepRef = useRef(0);

  const playSynthDrum = (type, time) => {
    const ctx = audioCtxRef.current;
    if (!ctx) return;

    const masterGain = ctx.createGain();
    masterGain.gain.value = masterVol * 0.7; 
    masterGain.connect(ctx.destination);

    if (type === 'BD') {
      const osc = ctx.createOscillator();
      const gain = ctx.createGain();
      osc.connect(gain); gain.connect(masterGain);
      osc.frequency.setValueAtTime(150, time);
      osc.frequency.exponentialRampToValueAtTime(0.001, time + 0.5);
      gain.gain.setValueAtTime(1, time);
      gain.gain.exponentialRampToValueAtTime(0.001, time + 0.5);
      osc.start(time); osc.stop(time + 0.5);
    } else if (type === 'SD') {
      const osc = ctx.createOscillator(); osc.type = 'triangle';
      const oscGain = ctx.createGain(); osc.connect(oscGain); oscGain.connect(masterGain);
      osc.frequency.setValueAtTime(250, time);
      oscGain.gain.setValueAtTime(0.5, time); oscGain.gain.exponentialRampToValueAtTime(0.01, time + 0.2);
      osc.start(time); osc.stop(time + 0.2);
      
      const bufferSize = ctx.sampleRate * 0.2; 
      const buffer = ctx.createBuffer(1, bufferSize, ctx.sampleRate);
      const data = buffer.getChannelData(0);
      for (let i = 0; i < bufferSize; i++) data[i] = Math.random() * 2 - 1;
      const noise = ctx.createBufferSource(); noise.buffer = buffer;
      const noiseFilter = ctx.createBiquadFilter(); noiseFilter.type = 'highpass'; noiseFilter.frequency.value = 1000;
      const noiseGain = ctx.createGain(); noiseGain.gain.setValueAtTime(1, time); noiseGain.gain.exponentialRampToValueAtTime(0.01, time + 0.2);
      noise.connect(noiseFilter); noiseFilter.connect(noiseGain); noiseGain.connect(masterGain);
      noise.start(time);
    } else if (type === 'CH' || type === 'OH') {
      const duration = type === 'CH' ? 0.05 : 0.3;
      const bufferSize = ctx.sampleRate * duration; 
      const buffer = ctx.createBuffer(1, bufferSize, ctx.sampleRate);
      const data = buffer.getChannelData(0);
      for (let i = 0; i < bufferSize; i++) data[i] = Math.random() * 2 - 1;
      const noise = ctx.createBufferSource(); noise.buffer = buffer;
      const bandpass = ctx.createBiquadFilter(); bandpass.type = 'bandpass'; bandpass.frequency.value = 10000;
      const gain = ctx.createGain(); gain.gain.setValueAtTime(0.3, time); gain.gain.exponentialRampToValueAtTime(0.01, time + duration);
      noise.connect(bandpass); bandpass.connect(gain); gain.connect(masterGain);
      noise.start(time);
    }
  };

  const scheduleNote = useCallback((stepNumber, time) => {
    setTimeout(() => setCurrentStep(stepNumber), (time - audioCtxRef.current.currentTime) * 1000);
    if (grid[0][stepNumber]) playSynthDrum('BD', time);
    if (grid[1][stepNumber]) playSynthDrum('SD', time);
    if (grid[2][stepNumber]) playSynthDrum('CH', time);
    if (grid[3][stepNumber]) playSynthDrum('OH', time);
  }, [grid, masterVol]);

  const scheduler = useCallback(() => {
    if (!audioCtxRef.current) return;
    while (nextNoteTimeRef.current < audioCtxRef.current.currentTime + 0.1) {
      scheduleNote(currentStepRef.current, nextNoteTimeRef.current);
      nextNoteTimeRef.current += 0.25 * (60.0 / bpm);
      currentStepRef.current = (currentStepRef.current + 1) % 16;
    }
    timerIDRef.current = setTimeout(scheduler, 25);
  }, [bpm, scheduleNote]);

  useEffect(() => {
    if (isBeatmakerPlaying) {
      if(audioCtxRef.current && audioCtxRef.current.state === 'suspended') audioCtxRef.current.resume();
      nextNoteTimeRef.current = audioCtxRef.current.currentTime + 0.05;
      scheduler();
    } else {
      clearTimeout(timerIDRef.current);
    }
    return () => clearTimeout(timerIDRef.current);
  }, [isBeatmakerPlaying, scheduler]);

  // --- RENDER DECK ---
  const renderDeck = (id, state, setState, audioRef) => {
     const progress = state.duration ? (state.currentTime / state.duration) * 100 : 0;
     const formatTime = (sec) => {
        const m = Math.floor(sec / 60);
        const s = Math.floor(sec % 60);
        return `${m}:${s < 10 ? '0' : ''}${s}`;
     };

     return (
       <div className="bg-[#1a1a1a] p-4 md:p-6 rounded-xl border-2 border-[#2a2a2a] shadow-[0_15px_30px_rgba(0,0,0,0.8),inset_0_2px_2px_rgba(255,255,255,0.05)] flex flex-col gap-6 w-full lg:w-[400px]">
          
          <div className="flex flex-col gap-2">
            <div className="flex justify-between items-center px-1">
               <span className="text-stone-500 font-black text-xl tracking-widest">DECK {id}</span>
               <label className="cursor-pointer bg-stone-800 hover:bg-stone-700 p-2 rounded shadow-md border border-stone-700 flex gap-2 items-center transition-colors">
                  <Upload size={14} className="text-stone-300" />
                  <span className="text-xs font-bold text-stone-300">LOAD</span>
                  <input type="file" accept="audio/*" className="hidden" onChange={(e) => handleFileUpload(id, e)} />
               </label>
            </div>
            
            {/* DISPLAY */}
            <div className="bg-[#050505] border-2 border-[#222] rounded-lg p-3 shadow-[inset_0_0_15px_rgba(0,0,0,1)] relative overflow-hidden h-20 flex flex-col justify-between">
               <div className="absolute inset-0 bg-[repeating-linear-gradient(transparent,transparent_2px,rgba(0,0,0,0.5)_2px,rgba(0,0,0,0.5)_4px)] pointer-events-none opacity-50"></div>
               
               <div className="flex justify-between items-start z-10 text-[#5eead4]">
                  <p className="text-xs font-mono font-bold truncate max-w-[70%]">{state.fileName}</p>
                  <div className="flex flex-col items-end">
                     <p className="text-sm font-mono font-bold">{formatTime(state.currentTime)}</p>
                     {state.loopActive && <span className="text-[9px] font-black text-yellow-400 animate-pulse bg-yellow-900/50 px-1 rounded mt-0.5">LOOP</span>}
                  </div>
               </div>
               
               {/* PROGRESS BAR & LOOP VIZUALIZACE */}
               <div className="h-6 bg-[#111] w-full rounded relative z-10 overflow-hidden border border-[#222]">
                  {/* Přehrávání */}
                  <div className={`absolute top-0 left-0 h-full opacity-80 ${id === 'A' ? 'bg-[#3b82f6]' : 'bg-[#ef4444]'}`} style={{ width: `${progress}%` }}></div>
                  
                  {/* Zobrazení uložené smyčky (žlutý pruh/čára) */}
                  {state.duration > 0 && state.loopIn !== null && state.loopOut !== null && (
                    <div className="absolute top-0 h-full bg-yellow-400/40 z-20 border-l border-r border-yellow-400"
                         style={{
                           left: `${(state.loopIn / state.duration) * 100}%`,
                           width: `${((state.loopOut - state.loopIn) / state.duration) * 100}%`
                         }}></div>
                  )}
                  {state.duration > 0 && state.loopIn !== null && state.loopOut === null && (
                    <div className="absolute top-0 h-full w-[2px] bg-yellow-400 z-20 shadow-[0_0_5px_yellow]"
                         style={{ left: `${(state.loopIn / state.duration) * 100}%` }}></div>
                  )}
               </div>
            </div>
          </div>

          <div className="flex gap-4">
            <div className="flex flex-col gap-4 flex-1">
               
               {/* HOT CUES */}
               <div className="grid grid-cols-3 gap-2">
                  {[0, 1, 2].map(i => (
                    <button 
                       key={i} onClick={() => handleHotCue(id, i)}
                       className={`h-9 rounded bg-stone-900 border-b-4 active:border-b-0 active:translate-y-1 transition-all shadow-[0_5px_10px_rgba(0,0,0,0.5)] flex items-center justify-center text-[10px] font-bold
                       ${state.hotCues[i] !== null 
                           ? (id === 'A' ? 'border-blue-600 text-blue-400' : 'border-red-600 text-red-400') 
                           : 'border-stone-700 text-stone-500 hover:bg-stone-800'}`}
                    >
                       HOT {i+1}
                    </button>
                  ))}
               </div>

               {/* LOOP SECTION */}
               <div className="grid grid-cols-3 gap-2 bg-[#111] p-1.5 rounded-lg border border-[#333]">
                  <button 
                     onClick={() => handleLoopIn(id)}
                     className={`h-9 rounded bg-stone-900 border-b-4 active:border-b-0 active:translate-y-1 transition-all shadow-[0_5px_10px_rgba(0,0,0,0.5)] flex items-center justify-center text-[10px] font-bold 
                     ${state.loopIn !== null ? 'border-yellow-600 text-yellow-400' : 'border-stone-700 text-stone-500 hover:bg-stone-800'}`}
                  >IN</button>
                  <button 
                     onClick={() => handleLoopOut(id)}
                     className={`h-9 rounded bg-stone-900 border-b-4 active:border-b-0 active:translate-y-1 transition-all shadow-[0_5px_10px_rgba(0,0,0,0.5)] flex items-center justify-center text-[10px] font-bold 
                     ${state.loopOut !== null ? 'border-yellow-600 text-yellow-400' : 'border-stone-700 text-stone-500 hover:bg-stone-800'}`}
                  >OUT</button>
                  <button 
                     onClick={() => toggleLoop(id)}
                     className={`h-9 rounded border-b-4 active:border-b-0 active:translate-y-1 transition-all shadow-[0_5px_10px_rgba(0,0,0,0.5)] flex items-center justify-center text-[10px] font-bold 
                     ${state.loopActive 
                        ? 'bg-yellow-600/20 border-yellow-500 text-yellow-400 shadow-[0_0_15px_rgba(234,179,8,0.3)]' 
                        : (state.loopIn !== null && state.loopOut !== null ? 'bg-stone-900 border-stone-600 text-stone-300' : 'bg-stone-900 border-stone-700 text-stone-600')}`}
                  >
                     {state.loopActive ? 'EXIT' : 'RELOOP'}
                  </button>
               </div>

               <div className="flex justify-center py-2">
                  <JogWheel isPlaying={state.isPlaying} progress={progress} onScrub={(delta) => handleScrub(id, delta)} />
               </div>

               <div className="flex gap-4 mt-auto">
                  <button 
                    onClick={() => handleCue(id)}
                    className="flex-1 h-14 bg-stone-800 rounded-full border-2 border-stone-600 shadow-[0_5px_15px_rgba(0,0,0,0.5)] hover:bg-stone-700 active:scale-95 transition-all flex items-center justify-center touch-manipulation"
                  >
                     <span className="text-orange-500 font-black tracking-wider shadow-orange-500/50 drop-shadow-md">CUE</span>
                  </button>
                  <button 
                    onClick={() => togglePlay(id)}
                    className="flex-1 h-14 bg-stone-800 rounded-full border-2 border-stone-600 shadow-[0_5px_15px_rgba(0,0,0,0.5)] hover:bg-stone-700 active:scale-95 transition-all flex items-center justify-center touch-manipulation"
                  >
                     {state.isPlaying 
                        ? <Pause size={24} className={id === 'A' ? 'text-blue-500' : 'text-red-500'} /> 
                        : <Play size={24} className="text-emerald-500 ml-1" />}
                  </button>
               </div>
            </div>

            <div className="w-16 bg-[#111] p-2 rounded-lg border border-[#333] shadow-inner flex flex-col items-center">
               <span className="text-[9px] text-stone-500 font-bold mb-4">TEMPO</span>
               <div className="flex-1 w-full flex justify-center py-2 touch-none">
                  <input 
                     type="range" min="0.8" max="1.2" step="0.001" 
                     value={state.pitch} 
                     onChange={(e) => setState(p => ({...p, pitch: parseFloat(e.target.value)}))}
                     className="w-full h-full appearance-none bg-transparent cursor-ns-resize touch-none [writing-mode:bt-lr]
                     [&::-webkit-slider-runnable-track]:w-1 [&::-webkit-slider-runnable-track]:bg-stone-900 [&::-webkit-slider-runnable-track]:rounded-full
                     [&::-webkit-slider-thumb]:appearance-none [&::-webkit-slider-thumb]:w-8 [&::-webkit-slider-thumb]:h-4 [&::-webkit-slider-thumb]:bg-stone-300 [&::-webkit-slider-thumb]:rounded-sm [&::-webkit-slider-thumb]:-ml-3.5 z-10"
                     style={{ WebkitAppearance: 'slider-vertical' }}
                  />
               </div>
               <span className="text-[10px] text-stone-400 font-mono mt-4">
                  {(state.pitch * 100).toFixed(1)}%
               </span>
               <button 
                  onClick={() => setState(p => ({...p, pitch: 1}))}
                  className="mt-2 w-4 h-4 rounded-full bg-stone-800 border border-stone-600 flex items-center justify-center active:bg-stone-600"
               >
                  {Math.abs(state.pitch - 1) < 0.01 && <div className="w-2 h-2 rounded-full bg-emerald-500 shadow-[0_0_5px_#10b981]"></div>}
               </button>
            </div>
          </div>

          <audio ref={audioRef} src={state.src} onTimeUpdate={() => handleTimeUpdate(id)} onEnded={() => setState(p => ({...p, isPlaying: false}))} crossOrigin="anonymous"/>
       </div>
     );
  }

  return (
    <div className="min-h-screen bg-[#0a0a0a] text-stone-200 p-2 md:p-6 font-sans select-none overflow-x-hidden">
      
      {/* POWER OVERLAY */}
      {!isPowered && (
         <div className="fixed inset-0 z-50 bg-black/90 flex flex-col items-center justify-center gap-6 backdrop-blur-sm">
            <div className="flex flex-col items-center gap-2">
               <h1 className="text-5xl font-black text-white tracking-widest text-center">Dj Adam</h1>
               <span className="text-emerald-500 font-mono tracking-widest text-lg uppercase">virtual mix</span>
            </div>
            <p className="text-stone-400 text-center max-w-md mt-4">Pro spuštění zvukového enginu Web Audio API a aktivaci hardwaru klikněte na tlačítko níže.</p>
            <button 
               onClick={powerOn}
               className="w-32 h-32 rounded-full bg-stone-900 border-4 border-stone-800 shadow-[0_0_50px_rgba(0,0,0,1)] hover:border-emerald-500 hover:shadow-[0_0_30px_rgba(16,185,129,0.3)] transition-all flex items-center justify-center group touch-manipulation"
            >
               <Power size={48} className="text-stone-600 group-hover:text-emerald-500 transition-colors" />
            </button>
         </div>
      )}

      {/* HEADER */}
      <header className="flex justify-between items-center mb-6 px-4 py-3 bg-[#111] rounded-lg border border-[#222]">
        <div className="flex items-baseline gap-4">
          <Settings2 size={24} className="text-emerald-500 hidden md:block" />
          <h1 className="text-2xl font-black tracking-widest text-white">
            Dj Adam
          </h1>
          <span className="text-sm font-bold text-emerald-500 tracking-wider uppercase bg-emerald-500/10 px-2 py-1 rounded">virtual mix</span>
        </div>
        
        {/* Master Section Top */}
        <div className="flex items-center gap-6 bg-[#0a0a0a] p-2 px-6 rounded-md border border-[#222]">
           <span className="text-xs font-bold text-stone-500 hidden md:inline">MASTER OUT</span>
           <Knob value={masterVol} min={0} max={1} onChange={setMasterVol} size={36} color="bg-stone-900" indicatorColor="bg-emerald-500" />
        </div>
      </header>

      {/* MAIN DJ LAYOUT */}
      <div className="flex flex-col xl:flex-row gap-6 justify-center items-stretch mb-6">
        
        {/* DECK A */}
        {renderDeck('A', deckA, setDeckA, audioRefA)}

        {/* 2-CHANNEL MIXER */}
        <div className="bg-[#151515] p-6 rounded-xl border-2 border-[#2a2a2a] shadow-[0_20px_40px_rgba(0,0,0,0.9),inset_0_2px_5px_rgba(255,255,255,0.05)] w-full xl:w-[350px] flex flex-col justify-between relative">
           <div className="absolute top-2 left-2 w-2 h-2 rounded-full bg-[#0a0a0a] border border-[#333] shadow-inner"></div>
           <div className="absolute top-2 right-2 w-2 h-2 rounded-full bg-[#0a0a0a] border border-[#333] shadow-inner"></div>
           <div className="absolute bottom-2 left-2 w-2 h-2 rounded-full bg-[#0a0a0a] border border-[#333] shadow-inner"></div>
           <div className="absolute bottom-2 right-2 w-2 h-2 rounded-full bg-[#0a0a0a] border border-[#333] shadow-inner"></div>

           <h3 className="text-center text-[#444] font-black tracking-[0.3em] text-sm mb-6 uppercase">Mixer</h3>

           <div className="flex justify-between w-full flex-1 px-4 gap-4">
              
              {/* Kanál A */}
              <div className="flex flex-col items-center gap-4 w-1/2 bg-[#1a1a1a] p-2 rounded-lg border border-[#222] shadow-inner py-4">
                 <div className="w-full text-center border-b border-[#333] pb-2 text-xs font-bold text-stone-500">CH 1</div>
                 
                 <Knob value={deckA.vol} min={0} max={1} onChange={(v) => setDeckA(p => ({...p, vol: v}))} label="TRIM" size={32} indicatorColor="bg-white" />
                 <div className="w-8 h-[1px] bg-[#333] my-1"></div>
                 <Knob value={deckA.eqHigh} min={-40} max={15} onChange={(v) => setDeckA(p => ({...p, eqHigh: v}))} label="HI" size={36} />
                 <Knob value={deckA.eqMid} min={-40} max={15} onChange={(v) => setDeckA(p => ({...p, eqMid: v}))} label="MID" size={36} />
                 <Knob value={deckA.eqLow} min={-40} max={15} onChange={(v) => setDeckA(p => ({...p, eqLow: v}))} label="LOW" size={36} />
                 <div className="w-8 h-[1px] bg-[#333] my-1"></div>
                 <Knob value={deckA.filter} min={-1} max={1} onChange={(v) => setDeckA(p => ({...p, filter: v}))} label="FILTER" size={44} color="bg-stone-800" indicatorColor={deckA.filter !== 0 ? "bg-blue-400" : "bg-stone-500"} />
                 <div className="w-8 h-[1px] bg-[#333] my-1"></div>
                 
                 {/* FX SEKCE A */}
                 <div className="flex flex-col items-center gap-1 w-full mt-1">
                    <div className="flex gap-1 mb-1">
                       <button onClick={() => setDeckA(p => ({...p, fxType: 'echo'}))} className={`text-[8px] px-2 py-1 rounded font-bold transition-colors ${deckA.fxType === 'echo' ? 'bg-emerald-500 text-black' : 'bg-stone-800 text-stone-400 hover:bg-stone-700'}`}>ECHO</button>
                       <button onClick={() => setDeckA(p => ({...p, fxType: 'reverb'}))} className={`text-[8px] px-2 py-1 rounded font-bold transition-colors ${deckA.fxType === 'reverb' ? 'bg-purple-500 text-black' : 'bg-stone-800 text-stone-400 hover:bg-stone-700'}`}>VERB</button>
                    </div>
                    <Knob value={deckA.fxAmount} min={0} max={1} onChange={(v) => setDeckA(p => ({...p, fxAmount: v}))} label="FX LVL" size={32} color="bg-stone-800" indicatorColor={deckA.fxAmount > 0 ? (deckA.fxType === 'echo' ? 'bg-emerald-400' : 'bg-purple-400') : 'bg-stone-500'} />
                 </div>

                 <div className="mt-2 w-full flex justify-center">
                    <VLevelFader value={deckA.vol} min={0} max={1} onChange={(v) => setDeckA(p => ({...p, vol: v}))} />
                 </div>
              </div>

              {/* Kanál B */}
              <div className="flex flex-col items-center gap-4 w-1/2 bg-[#1a1a1a] p-2 rounded-lg border border-[#222] shadow-inner py-4">
                 <div className="w-full text-center border-b border-[#333] pb-2 text-xs font-bold text-stone-500">CH 2</div>

                 <Knob value={deckB.vol} min={0} max={1} onChange={(v) => setDeckB(p => ({...p, vol: v}))} label="TRIM" size={32} indicatorColor="bg-white" />
                 <div className="w-8 h-[1px] bg-[#333] my-1"></div>
                 <Knob value={deckB.eqHigh} min={-40} max={15} onChange={(v) => setDeckB(p => ({...p, eqHigh: v}))} label="HI" size={36} />
                 <Knob value={deckB.eqMid} min={-40} max={15} onChange={(v) => setDeckB(p => ({...p, eqMid: v}))} label="MID" size={36} />
                 <Knob value={deckB.eqLow} min={-40} max={15} onChange={(v) => setDeckB(p => ({...p, eqLow: v}))} label="LOW" size={36} />
                 <div className="w-8 h-[1px] bg-[#333] my-1"></div>
                 <Knob value={deckB.filter} min={-1} max={1} onChange={(v) => setDeckB(p => ({...p, filter: v}))} label="FILTER" size={44} color="bg-stone-800" indicatorColor={deckB.filter !== 0 ? "bg-red-400" : "bg-stone-500"} />
                 <div className="w-8 h-[1px] bg-[#333] my-1"></div>

                 {/* FX SEKCE B */}
                 <div className="flex flex-col items-center gap-1 w-full mt-1">
                    <div className="flex gap-1 mb-1">
                       <button onClick={() => setDeckB(p => ({...p, fxType: 'echo'}))} className={`text-[8px] px-2 py-1 rounded font-bold transition-colors ${deckB.fxType === 'echo' ? 'bg-emerald-500 text-black' : 'bg-stone-800 text-stone-400 hover:bg-stone-700'}`}>ECHO</button>
                       <button onClick={() => setDeckB(p => ({...p, fxType: 'reverb'}))} className={`text-[8px] px-2 py-1 rounded font-bold transition-colors ${deckB.fxType === 'reverb' ? 'bg-purple-500 text-black' : 'bg-stone-800 text-stone-400 hover:bg-stone-700'}`}>VERB</button>
                    </div>
                    <Knob value={deckB.fxAmount} min={0} max={1} onChange={(v) => setDeckB(p => ({...p, fxAmount: v}))} label="FX LVL" size={32} color="bg-stone-800" indicatorColor={deckB.fxAmount > 0 ? (deckB.fxType === 'echo' ? 'bg-emerald-400' : 'bg-purple-400') : 'bg-stone-500'} />
                 </div>

                 <div className="mt-2 w-full flex justify-center">
                    <VLevelFader value={deckB.vol} min={0} max={1} onChange={(v) => setDeckB(p => ({...p, vol: v}))} />
                 </div>
              </div>

           </div>

           {/* Crossfader sekce dole */}
           <div className="mt-8 px-4 w-full">
              <div className="flex justify-between text-[10px] font-black text-stone-500 mb-2 px-2">
                 <span>A</span>
                 <span>CROSSFADER</span>
                 <span>B</span>
              </div>
              <Crossfader value={crossfader} onChange={setCrossfader} />
           </div>

        </div>

        {/* DECK B */}
        {renderDeck('B', deckB, setDeckB, audioRefB)}

      </div>

      {/* RHYTHM SECTION (Beatmaker TR-Style) */}
      <div className="bg-[#111] p-4 md:p-6 rounded-xl border-t-4 border-emerald-900 shadow-2xl mt-4 mb-10">
         <div className="flex flex-col md:flex-row justify-between items-start md:items-center mb-6 gap-4 border-b border-[#222] pb-4">
            <div className="flex items-center gap-3">
               <div className="p-2 bg-emerald-900/30 rounded border border-emerald-800">
                  <Music size={24} className="text-emerald-500" />
               </div>
               <div>
                  <h2 className="text-xl font-black text-white tracking-widest">RHYTHM PERFORMER</h2>
                  <p className="text-xs text-stone-500 font-mono">INTEGROVANÝ BEATMAKER</p>
               </div>
            </div>

            <div className="flex items-center gap-6 bg-[#0a0a0a] p-2 px-4 rounded-lg border border-[#222]">
               <button 
                  onClick={() => setIsBeatmakerPlaying(!isBeatmakerPlaying)}
                  className={`w-12 h-10 rounded border-2 shadow-[0_2px_5px_rgba(0,0,0,0.5)] flex items-center justify-center transition-all touch-manipulation ${isBeatmakerPlaying ? 'bg-emerald-500 border-emerald-400 text-black shadow-[0_0_15px_#10b981]' : 'bg-stone-800 border-stone-600 text-stone-400'}`}
                >
                  {isBeatmakerPlaying ? <Pause size={18} fill="currentColor" /> : <Play size={18} fill="currentColor" />}
               </button>

               <div className="flex items-center gap-2">
                  <span className="text-[10px] font-black text-stone-500 tracking-wider">BPM</span>
                  <input 
                    type="number" 
                    value={bpm} 
                    onChange={(e) => setBpm(Number(e.target.value))}
                    className="bg-[#111] text-emerald-400 px-2 py-1 rounded w-16 text-center font-mono text-lg outline-none border border-[#333] focus:border-emerald-500"
                  />
               </div>
            </div>
         </div>

         <div className="overflow-x-auto pb-2 touch-manipulation">
            <div className="flex flex-col gap-3 min-w-max">
               {[
                  { id: 'BD', name: 'BASS DRUM', color: 'bg-red-500' },
                  { id: 'SD', name: 'SNARE DRUM', color: 'bg-orange-500' },
                  { id: 'CH', name: 'CLOSED HAT', color: 'bg-yellow-500' },
                  { id: 'OH', name: 'OPEN HAT', color: 'bg-yellow-600' }
               ].map((inst, rowIndex) => (
                  <div key={inst.id} className="flex items-center gap-4">
                     <div className="w-28 text-[10px] font-black text-stone-400 tracking-widest text-right">
                        {inst.name}
                     </div>
                     <div className="flex gap-1">
                        {grid[rowIndex].map((isActive, colIndex) => (
                           <button
                              key={colIndex}
                              onClick={() => {
                                 const newGrid = [...grid];
                                 newGrid[rowIndex][colIndex] = !newGrid[rowIndex][colIndex];
                                 setGrid(newGrid);
                              }}
                              className={`w-8 h-12 md:w-10 md:h-14 rounded-sm border-b-4 transition-all relative flex flex-col justify-end p-1 touch-manipulation
                                 ${isActive 
                                    ? `${inst.color} border-[#000] shadow-[0_0_10px_currentColor]` 
                                    : 'bg-stone-800 border-stone-900 hover:bg-stone-700'}
                                 ${colIndex % 4 === 0 && !isActive ? 'bg-stone-800 brightness-125' : ''}
                              `}
                           >
                              <div className={`w-full h-1 rounded-full ${currentStep === colIndex && isBeatmakerPlaying ? 'bg-white shadow-[0_0_5px_white]' : 'bg-black/20'}`}></div>
                           </button>
                        ))}
                     </div>
                  </div>
               ))}
            </div>
         </div>
      </div>

    </div>
  );
}